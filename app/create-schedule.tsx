// @ts-nocheck
import React, { useState, useMemo, useCallback, useEffect } from 'react';
import {
  View,
  Text,
  ScrollView,
  TouchableOpacity,
  StyleSheet,
  Platform,
} from 'react-native';
import { useLocalSearchParams, useRouter } from 'expo-router';
import { ChevronLeft, ChevronRight } from 'lucide-react-native';

import { useSchedule } from '../hooks/schedule-store';
import { persistFinish } from '../hooks/persist-finish';
import {
  STAFF,
  PARTICIPANTS,
  CLEANING_TASKS,
  FLOATING_TIME_SLOTS,
} from '@constants/data';
import * as Data from '../constants/data';
import ROUTES from '../constants/routes';
import { useTodayLabel } from '../components/use-today-label';

const PILL = 999;

// Helper
function safeArray<T>(val: T[] | undefined | null, fallback: T[] = []): T[] {
  return Array.isArray(val) ? val : fallback;
}

// Small chips used in multiple steps
type ChipProps = {
  label: string;
  selected?: boolean;
  onPress?: () => void;
  rightAddon?: React.ReactNode;
  disabled?: boolean;
};

function Chip({ label, selected, onPress, rightAddon, disabled }: ChipProps) {
  return (
    <TouchableOpacity
      disabled={disabled}
      onPress={onPress}
      activeOpacity={0.8}
      style={[
        styles.chip,
        selected && styles.chipSel,
        disabled && { opacity: 0.4 },
      ]}
    >
      <Text style={[styles.chipTxt, selected && styles.chipTxtSel]}>
        {label}
      </Text>
      {rightAddon}
    </TouchableOpacity>
  );
}

// Helper to derive attending participants from state
function deriveAttendingParticipants(
  allParticipants: typeof PARTICIPANTS,
  attendingIds: string[],
) {
  const attendingSet = new Set(attendingIds);
  return allParticipants.filter((p) => attendingSet.has(p.id));
}

// ---- MAIN SCREEN ------------------------------------------------------------

export default function CreateScheduleScreen() {
  const router = useRouter();
  const { date } = useLocalSearchParams<{ date?: string }>();
  const {
    workingStaff: storedWorkingStaff,
    attendingParticipants: storedAttending,
    participantAssignments,
    pickups,
    dropoffAssignments,
    dropoffHelpers,
    cleaningAssignments,
    floatingAssignments,
    updateSchedule,
    reset,
  } = useSchedule();

  const todayLabel = useTodayLabel(date ?? undefined);

  // ---- LOCAL STATE (initially from store, but with safe fallbacks) ----------

  // Only Everyone on by default
  const [workingStaff, setWorkingStaff] = useState<string[]>(
    storedWorkingStaff && storedWorkingStaff.length > 0
      ? storedWorkingStaff
      : ['everyone'],
  );

  const [attendingParticipants, setAttendingParticipants] = useState<string[]>(
    safeArray(storedAttending, []),
  );

  const [assignments, setAssignments] = useState<{
    [staffId: string]: string[];
  }>(() => {
    if (participantAssignments) return participantAssignments;
    return {};
  });

  const [pickupIds, setPickupIds] = useState<string[]>(() =>
    safeArray(pickups),
  );

  const [helpers, setHelpers] = useState<string[]>(() =>
    safeArray(dropoffHelpers),
  );

  const [dropoffs, setDropoffs] = useState<{ [staffId: string]: string[] }>(
    () => dropoffAssignments || {},
  );

  const [cleaning, setCleaning] = useState<{ [taskId: string]: string }>(
    () => cleaningAssignments || {},
  );

  const [floating, setFloating] = useState<{
    [slotId: string]: { front?: string; scotty?: string; twins?: string };
  }>(() => floatingAssignments || {});

  const [step, setStep] = useState<number>(1);
  const [showHelpers, setShowHelpers] = useState(false);
  const [autoGenerated, setAutoGenerated] = useState(false);

  const dateKey =
    typeof date === 'string' && date.length > 0 ? date : todayLabel.rawKey;

  // Persist full schedule on finish
  const handleFinish = async () => {
    const payload = {
      date: dateKey,
      workingStaff: workingStaff,
      attendingParticipants,
      participantAssignments: assignments,
      pickups: pickupIds,
      dropoffHelpers: helpers,
      dropoffAssignments: dropoffs,
      cleaningAssignments: cleaning,
      floatingAssignments: floating,
    };

    updateSchedule(payload);
    await persistFinish(payload);
    router.replace(ROUTES.EDIT_HUB);
  };

  const handleNext = () => {
    if (step < 6) setStep((s) => s + 1);
    else handleFinish();
  };

  const handleBack = () => {
    if (step > 1) setStep((s) => s - 1);
    else router.replace(ROUTES.HOME);
  };

  // ---- DERIVED DATA ---------------------------------------------------------

  const workingStaffSet = useMemo(() => new Set(workingStaff), [workingStaff]);

  const selectedWorkingStaff = useMemo(
    () => STAFF.filter((s) => workingStaffSet.has(s.id)),
    [workingStaffSet],
  );

  const nonWorkingStaff = useMemo(
    () => STAFF.filter((s) => !workingStaffSet.has(s.id)),
    [workingStaffSet],
  );

  const attendingSet = useMemo(
    () => new Set(attendingParticipants),
    [attendingParticipants],
  );

  const attendingList = useMemo(
    () => deriveAttendingParticipants(PARTICIPANTS, attendingParticipants),
    [attendingParticipants],
  );

  const availableParticipants = useMemo(
    () => PARTICIPANTS.filter((p) => !attendingSet.has(p.id)),
    [attendingSet],
  );

  const nonPickupParticipants = useMemo(() => {
    const pickSet = new Set(pickupIds);
    return attendingList.filter((p) => !pickSet.has(p.id));
  }, [pickupIds, attendingList]);

  const pickupSet = useMemo(() => new Set(pickupIds), [pickupIds]);

  const helpersSet = useMemo(() => new Set(helpers), [helpers]);

  const dropoffStaffIds = useMemo(
    () => selectedWorkingStaff.map((s) => s.id),
    [selectedWorkingStaff],
  );

  const allDropoffAssignedIds = useMemo(() => {
    const all = new Set<string>();
    Object.values(dropoffs).forEach((arr) => {
      arr.forEach((id) => all.add(id));
    });
    return all;
  }, [dropoffs]);

  const unassignedForDropoff = useMemo(() => {
    return nonPickupParticipants.filter((p) => !allDropoffAssignedIds.has(p.id));
  }, [nonPickupParticipants, allDropoffAssignedIds]);

  const dropoffViewByStaff = useMemo(
    () =>
      dropoffStaffIds.map((sid) => {
        const assignedIds = safeArray(dropoffs[sid], []);
        return {
          staffId: sid,
          assignedIds,
          unassignedIds: unassignedForDropoff.map((p) => p.id),
        };
      }),
    [dropoffStaffIds, dropoffs, unassignedForDropoff],
  );

  // ---- TOGGLE HANDLERS ------------------------------------------------------

  const toggleWorking = (id: string) => {
    // Everyone special case
    if (id === 'everyone') {
      const isOn = workingStaffSet.has('everyone');
      if (isOn) {
        setWorkingStaff(['everyone']);
      } else {
        setWorkingStaff(['everyone', ...STAFF.map((s) => s.id)]);
      }
      return;
    }

    const next = new Set(workingStaff);
    if (next.has(id)) next.delete(id);
    else next.add(id);
    if (!next.has('everyone')) {
      next.add('everyone');
    }
    setWorkingStaff(Array.from(next));
  };

  const toggleAttending = (id: string) => {
    const next = new Set(attendingParticipants);
    if (next.has(id)) next.delete(id);
    else next.add(id);
    setAttendingParticipants(Array.from(next));
  };

  const toggleAssignment = (staffId: string, participantId: string) => {
    setAssignments((prev) => {
      const next: { [sid: string]: string[] } = { ...prev };
      const current = new Set(next[staffId] || []);

      if (current.has(participantId)) current.delete(participantId);
      else current.add(participantId);

      next[staffId] = Array.from(current);
      return next;
    });
  };

  const togglePickup = (id: string) => {
    setPickupIds((prev) => {
      const set = new Set(prev);
      if (set.has(id)) set.delete(id);
      else set.add(id);
      return Array.from(set);
    });
  };

  const toggleHelper = (id: string) => {
    setHelpers((prev) => {
      const set = new Set(prev);
      if (set.has(id)) set.delete(id);
      else set.add(id);
      return Array.from(set);
    });
  };

  const toggleDropoffParticipant = (staffId: string, participantId: string) => {
    setDropoffs((prev) => {
      const next = { ...prev };
      const staffSet = new Set(next[staffId] || []);
      const assignedElsewhere = Object.entries(next).some(
        ([sid, arr]) => sid !== staffId && safeArray(arr).includes(participantId),
      );

      if (staffSet.has(participantId)) {
        staffSet.delete(participantId);
      } else {
        if (assignedElsewhere) {
          // remove from other staff first
          Object.entries(next).forEach(([sid, arr]) => {
            if (sid === staffId) return;
            if (safeArray(arr).includes(participantId)) {
              next[sid] = safeArray(arr).filter((id) => id !== participantId);
            }
          });
        }
        staffSet.add(participantId);
      }

      next[staffId] = Array.from(staffSet);
      return next;
    });
  };

  const toggleCleaning = (taskId: string, staffId: string) => {
    setCleaning((prev) => {
      if (prev[taskId] === staffId) {
        const next = { ...prev };
        delete next[taskId];
        return next;
      }
      return { ...prev, [taskId]: staffId };
    });
  };

  const toggleFloatingSlot = (
    slotId: string,
    column: 'front' | 'scotty' | 'twins',
    staffId: string,
  ) => {
    setFloating((prev) => {
      const next = { ...prev };
      const row = next[slotId] || {};
      next[slotId] = {
        ...row,
        [column]: row[column] === staffId ? undefined : staffId,
      };
      return next;
    });
  };

  // Auto-assign cleaning & floating based on working staff + attending list
  const runAutoAssignments = useCallback(() => {
    const working = selectedWorkingStaff;
    if (!working.length) return;

    const workingIds = working.map((s) => s.id);

    // --- Cleaning: simple round-robin over tasks
    const cleaningMap: { [taskId: string]: string } = {};
    CLEANING_TASKS.forEach((task, idx) => {
      const staffId = workingIds[idx % workingIds.length];
      cleaningMap[task.id] = staffId;
    });

    // --- Floating: deterministic rotation
    const floatMap: {
      [slotId: string]: { front?: string; scotty?: string; twins?: string };
    } = {};

    FLOATING_TIME_SLOTS.forEach((slot, index) => {
      const front = workingIds[index % workingIds.length];
      const scotty = workingIds[(index + 1) % workingIds.length];
      const twins = workingIds[(index + 2) % workingIds.length];

      floatMap[slot.id] = {
        front,
        scotty,
        twins,
      };
    });

    setCleaning(cleaningMap);
    setFloating(floatMap);
    setAutoGenerated(true);
  }, [selectedWorkingStaff]);

  // ---------------------------------------------------------------------------
  // STEP SUBCOMPONENTS
  // ---------------------------------------------------------------------------

  const Step1 = () => {
    const selected = new Set(workingStaff);

    const staffSorted = [...STAFF].sort((a, b) =>
      a.name.localeCompare(b.name, 'en', { sensitivity: 'base' }),
    );

    const topSelected = staffSorted.filter((s) => selected.has(s.id));
    const remaining = staffSorted.filter((s) => !selected.has(s.id));

    return (
      <View style={styles.section}>
        <Text style={styles.title}>Dream Team (Working @ B2)</Text>
        <Text style={styles.subTitle}>
          Select who&apos;s working @ B2 today. &quot;Everyone&quot; lets you
          quickly toggle the whole team. Staff not working here can still be
          used as dropoff helpers later.
        </Text>

        <View style={styles.section}>
          <Text style={styles.sectionTitle}>Working @ B2 today</Text>

          {/* Everyone card */}
          <TouchableOpacity
            onPress={() => toggleWorking('everyone')}
            activeOpacity={0.85}
            style={[
              styles.tile,
              selected.has('everyone') && styles.tileSel,
              { marginBottom: 10 },
            ]}
          >
            <View style={[styles.rect, { backgroundColor: '#D0D5DD' }]} />
            <Text style={styles.tileName}>Everyone</Text>
          </TouchableOpacity>

          {/* Selected staff tiles */}
          {topSelected.length > 0 && (
            <View style={styles.tiles}>
              {topSelected.map((s) => (
                <TouchableOpacity
                  key={s.id}
                  onPress={() => toggleWorking(s.id)}
                  activeOpacity={0.85}
                  style={[
                    styles.tile,
                    selected.has(s.id) && styles.tileSel,
                    { flex: 1 },
                  ]}
                >
                  <View style={[styles.rect, { backgroundColor: s.color }]} />
                  <Text style={styles.tileName}>{s.name}</Text>
                  {selected.has(s.id) && (
                    <Text style={{ marginLeft: 'auto', color: '#175CD3' }}>
                      ✓
                    </Text>
                  )}
                </TouchableOpacity>
              ))}
            </View>
          )}

          {/* Remaining staff list */}
          {remaining.length > 0 && (
            <>
              <Text
                style={{
                  marginTop: 16,
                  fontSize: 13,
                  color: '#667085',
                }}
              >
                Team members
              </Text>
              <View style={styles.tiles}>
                {remaining.map((s) => (
                  <TouchableOpacity
                    key={s.id}
                    onPress={() => toggleWorking(s.id)}
                    activeOpacity={0.85}
                    style={[styles.tile, { flex: 1 }]}
                  >
                    <View
                      style={[styles.rect, { backgroundColor: s.color }]}
                    />
                    <Text style={styles.tileName}>{s.name}</Text>
                    {selected.has(s.id) && (
                      <Text style={{ marginLeft: 'auto', color: '#175CD3' }}>
                        ✓
                      </Text>
                    )}
                  </TouchableOpacity>
                ))}
              </View>
            </>
          )}

          {topSelected.length > 0 && (
            <Text style={styles.assignedSummary}>
              Working today:{' '}
              {topSelected.map((s) => s.name).sort().join(', ')}
            </Text>
          )}
        </View>
      </View>
    );
  };

  const Step2 = () => {
    const selected = new Set(attendingParticipants);

    const attendingSorted = [...PARTICIPANTS].sort((a, b) =>
      a.name.localeCompare(b.name, 'en', { sensitivity: 'base' }),
    );

    const topSelected = attendingSorted.filter((p) => selected.has(p.id));
    const remaining = attendingSorted.filter((p) => !selected.has(p.id));

    return (
      <View style={styles.section}>
        <Text style={styles.title}>Attending Participants</Text>
        <Text style={styles.subTitle}>
          Choose which participants are attending today. Only these will appear
          in the later assignment steps.
        </Text>

        <Text style={styles.sectionTitle}>Attending today</Text>
        <View style={styles.tiles}>
          {topSelected.length === 0 && (
            <Text style={styles.emptyHint}>
              Select at least one participant attending today.
            </Text>
          )}

          {topSelected.map((p) => (
            <TouchableOpacity
              key={p.id}
              onPress={() => toggleAttending(p.id)}
              activeOpacity={0.85}
              style={[
                styles.tile,
                selected.has(p.id) && styles.tileSel,
                { flex: 1 },
              ]}
            >
              <Text style={styles.tileName}>{p.name}</Text>
              {selected.has(p.id) && (
                <Text style={{ marginLeft: 'auto', color: '#175CD3' }}>✓</Text>
              )}
            </TouchableOpacity>
          ))}
        </View>

        {remaining.length > 0 && (
          <>
            <Text
              style={{
                marginTop: 16,
                fontSize: 13,
                color: '#667085',
              }}
            >
              Not attending
            </Text>
            <View style={styles.tiles}>
              {remaining.map((p) => (
                <TouchableOpacity
                  key={p.id}
                  onPress={() => toggleAttending(p.id)}
                  activeOpacity={0.85}
                  style={[styles.tile, { flex: 1 }]}
                >
                  <Text style={styles.tileName}>{p.name}</Text>
                  {selected.has(p.id) && (
                    <Text style={{ marginLeft: 'auto', color: '#175CD3' }}>
                      ✓
                    </Text>
                  )}
                </TouchableOpacity>
              ))}
            </View>
          </>
        )}
      </View>
    );
  };

  const Step3 = () => {
    return (
      <View style={styles.section}>
        <Text style={styles.title}>Team Daily Assignments</Text>
        <Text style={styles.subTitle}>
          Assign participants to each working staff member. &quot;Everyone&quot;
          can be used for shared activities.
        </Text>

        <View style={styles.assignmentsWrap}>
          {selectedWorkingStaff.map((s) => {
            const assignedIds = safeArray(assignments[s.id], []);
            const selectedSet = new Set(assignedIds);
            const chips = attendingList.map((p) => ({
              id: p.id,
              name: p.name,
              selected: selectedSet.has(p.id),
            }));

            return (
              <View key={s.id} style={styles.assignmentCard}>
                <View style={styles.assignmentHeader}>
                  <View
                    style={[styles.rect, { backgroundColor: s.color }]}
                  />
                  <Text style={styles.assignmentName}>{s.name}</Text>
                </View>
                <View style={styles.chipRow}>
                  {chips.map((c) => (
                    <Chip
                      key={c.id}
                      label={c.name}
                      selected={c.selected}
                      onPress={() => toggleAssignment(s.id, c.id)}
                    />
                  ))}
                </View>
              </View>
            );
          })}
        </View>
      </View>
    );
  };

  const Step4 = () => {
    const pickupsChips = attendingList.map((p) => ({
      id: p.id,
      name: p.name,
      selected: pickupSet.has(p.id),
    }));

    const helperCandidates = nonWorkingStaff;

    return (
      <View style={styles.section}>
        <Text style={styles.title}>Pickups & Dropoffs</Text>
        <Text style={styles.subTitle}>
          Select which participants are picked up by external transport, which
          staff will assist, and who is responsible for each dropoff. You can
          adjust everything later in the Edit Hub.
        </Text>

        {/* Pickups */}
        <Text style={styles.sectionTitle}>Pickups</Text>
        <Text style={styles.subTitle}>
          Select participants being picked up by external transport. These
          participants will not appear in the dropoff lists.
        </Text>
        <View style={styles.chipGrid}>
          {pickupsChips.map((c) => (
            <Chip
              key={c.id}
              label={c.name}
              selected={c.selected}
              onPress={() => togglePickup(c.id)}
            />
          ))}
        </View>

        {/* Helpers */}
        <View
          style={{
            marginTop: 24,
            flexDirection: 'row',
            justifyContent: 'space-between',
            alignItems: 'center',
          }}
        >
          <Text style={styles.sectionTitle}>Dropoff Helpers (optional)</Text>
          <TouchableOpacity
            onPress={() => setShowHelpers((v) => !v)}
            activeOpacity={0.8}
          >
            <Text style={{ fontSize: 13, color: '#175CD3', fontWeight: '600' }}>
              {showHelpers ? 'Hide helpers' : 'Show helpers'}
            </Text>
          </TouchableOpacity>
        </View>

        {showHelpers && (
          <>
            <Text style={styles.subTitle}>
              Select staff (not working @ B2) who will assist with pickups and
              dropoffs.
            </Text>
            <View style={styles.chipGrid}>
              {helperCandidates.map((s) => (
                <Chip
                  key={s.id}
                  label={s.name}
                  selected={helpersSet.has(s.id)}
                  onPress={() => toggleHelper(s.id)}
                />
              ))}
            </View>
          </>
        )}

        {/* Dropoffs */}
        <View style={{ marginTop: 24 }}>
          <Text style={styles.sectionTitle}>Dropoffs</Text>
          <Text style={styles.subTitle}>
            Assign each dropoff participant to one staff member. Participants in
            Pickups won&apos;t appear here. Tap a name to move them between
            staff members.
          </Text>

          {dropoffViewByStaff.map(({ staffId, assignedIds }) => {
            const staff = STAFF.find((s) => s.id === staffId);
            if (!staff) return null;
            const assignedParticipants = attendingList.filter((p) =>
              assignedIds.includes(p.id),
            );

            const unassigned = nonPickupParticipants.filter((p) => {
              if (assignedIds.includes(p.id)) return false;
              return !Object.values(dropoffs).some((arr) =>
                safeArray(arr).includes(p.id),
              );
            });

            const staffLabel = staff.name;

            return (
              <View key={staffId} style={styles.assignmentCard}>
                <View style={styles.assignmentHeader}>
                  <View
                    style={[styles.rect, { backgroundColor: staff.color }]}
                  />
                  <Text style={styles.assignmentName}>{staffLabel}</Text>
                </View>

                <Text style={styles.subTitle}>Assigned to {staffLabel}</Text>
                <View style={styles.chipRow}>
                  {assignedParticipants.length === 0 && (
                    <Text style={styles.emptyHint}>
                      No dropoff assignments yet.
                    </Text>
                  )}
                  {assignedParticipants.map((p) => (
                    <Chip
                      key={p.id}
                      label={p.name}
                      selected={true}
                      onPress={() =>
                        toggleDropoffParticipant(staffId, p.id)
                      }
                    />
                  ))}
                </View>

                {unassigned.length > 0 && (
                  <>
                    <Text
                      style={[
                        styles.subTitle,
                        { marginTop: 12, marginBottom: 4 },
                      ]}
                    >
                      Not assigned to {staffLabel}
                    </Text>
                    <View style={styles.chipRow}>
                      {unassigned.map((p) => (
                        <Chip
                          key={p.id}
                          label={p.name}
                          selected={false}
                          onPress={() =>
                            toggleDropoffParticipant(staffId, p.id)
                          }
                        />
                      ))}
                    </View>
                  </>
                )}
              </View>
            );
          })}
        </View>
      </View>
    );
  };

  const Step5 = () => {
    return (
      <View style={styles.section}>
        <Text style={styles.title}>Auto-Assignments</Text>
        <Text style={styles.subTitle}>
          Daily Schedule App will now generate Floating &amp; Cleaning
          auto-assignments based on your Dream Team and attending participants.
          You can review and adjust the details later in the Edit Hub.
        </Text>

        <TouchableOpacity
          onPress={runAutoAssignments}
          activeOpacity={0.9}
          style={[
            styles.nextBtn,
            {
              marginTop: 24,
              alignSelf: 'flex-start',
              paddingHorizontal: 16,
            },
          ]}
        >
          <Text style={styles.nextTxt}>
            {autoGenerated ? 'Re-generate assignments' : 'Generate assignments'}
          </Text>
        </TouchableOpacity>

        {autoGenerated && (
          <Text
            style={{
              marginTop: 8,
              fontSize: 13,
              color: '#12B76A',
              fontWeight: '600',
            }}
          >
            Auto-assignments updated. You can fine-tune them in the Edit Hub.
          </Text>
        )}
      </View>
    );
  };

  const Step6 = () => {
    const workingOnly = selectedWorkingStaff;

    return (
      <View style={styles.section}>
        <Text style={styles.title}>Final Checklist Assignment</Text>
        <Text style={styles.subTitle}>
          Choose who will be responsible for completing the End-of-Shift
          checklist. You can update this later in the Edit Hub.
        </Text>

        <View style={styles.tiles}>
          {workingOnly.map((s) => {
            const isSelected = cleaning['_finalStaff'] === s.id;
            return (
              <TouchableOpacity
                key={s.id}
                onPress={() =>
                  setCleaning((prev) => ({
                    ...prev,
                    _finalStaff: isSelected ? undefined : s.id,
                  }))
                }
                activeOpacity={0.85}
                style={[
                  styles.tile,
                  isSelected && styles.tileSel,
                  { flex: 1 },
                ]}
              >
                <View
                  style={[styles.rect, { backgroundColor: s.color }]}
                />
                <Text style={styles.tileName}>{s.name}</Text>
                {isSelected && (
                  <Text style={{ marginLeft: 'auto', color: '#175CD3' }}>
                    ✓
                  </Text>
                )}
              </TouchableOpacity>
            );
          })}
        </View>

        <Text style={styles.subTitle}>
          The selected staff member will be responsible for completing the
          End-of-Shift checklist.
        </Text>
      </View>
    );
  };

  // ---------------------------------------------------------------------------

  return (
    <View style={styles.container}>
      <View style={styles.header}>
        <TouchableOpacity
          onPress={handleBack}
          style={{ flexDirection: 'row', alignItems: 'center', gap: 4 }}
        >
          <ChevronLeft size={18} color="#344054" />
          <Text style={{ fontSize: 13, color: '#344054' }}>Back</Text>
        </TouchableOpacity>
        <Text style={styles.headerTitle}>Create Today&apos;s Schedule</Text>
        <Text style={styles.headerStep}>Step {step} of 6</Text>
        <View style={styles.progressOuter}>
          <View
            style={[
              styles.progressInner,
              { width: `${(step / 6) * 100}%` },
            ]}
          />
        </View>
        <View style={styles.datePill}>
          <Text style={styles.dateTxt}>{todayLabel.label}</Text>
        </View>
      </View>

      <ScrollView
        style={styles.page}
        contentContainerStyle={{ paddingBottom: 80 }}
        keyboardShouldPersistTaps="handled"
      >
        <View style={styles.inner}>
          <View style={{ marginTop: 16 }}>
            <Text style={{ fontSize: 13, color: '#667085' }}>
              Follow the steps below to create today&apos;s schedule. You can
              make adjustments later from the Edit Hub.
            </Text>
          </View>

          {step === 1 && <Step1 />}
          {step === 2 && <Step2 />}
          {step === 3 && <Step3 />}
          {step === 4 && <Step4 />}
          {step === 5 && <Step5 />}
          {step === 6 && <Step6 />}
        </View>
      </ScrollView>

      <View style={styles.footer}>
        <View style={styles.footerInner}>
          <TouchableOpacity
            onPress={handleBack}
            activeOpacity={0.85}
            style={[styles.btnBase, styles.backBtn]}
          >
            <Text style={styles.backTxt}>Back</Text>
          </TouchableOpacity>
          <TouchableOpacity
            onPress={handleNext}
            activeOpacity={0.9}
            style={[styles.btnBase, styles.nextBtn]}
          >
            <Text style={styles.nextTxt}>
              {step === 6 ? 'Finish & go to Edit Hub' : 'Next'}
            </Text>
          </TouchableOpacity>
        </View>
      </View>
    </View>
  );
}

// -----------------------------------------------------------------------------
// STYLES
// -----------------------------------------------------------------------------

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: '#F7F9FC' },
  page: { flex: 1, paddingHorizontal: 16 },
  inner: { width: '100%', maxWidth: 880, flex: 1, alignSelf: 'center' },
  header: {
    padding: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#E5ECF5',
    backgroundColor: '#FFF',
  },
  headerTitle: { fontSize: 20, fontWeight: '900', color: '#101828' },
  headerStep: { marginTop: 6, fontSize: 12, color: '#667085' },
  progressOuter: {
    marginTop: 8,
    height: 6,
    borderRadius: 999,
    backgroundColor: '#E5ECF5',
    overflow: 'hidden',
  },
  progressInner: {
    height: '100%',
    borderRadius: 999,
    backgroundColor: '#175CD3',
  },
  datePill: {
    marginTop: 16,
    alignSelf: 'flex-start',
    paddingHorizontal: 12,
    paddingVertical: 4,
    borderRadius: PILL,
    backgroundColor: '#EEF4FF',
  },
  dateTxt: { fontSize: 12, color: '#175CD3', fontWeight: '600' },

  section: { marginTop: 16, paddingBottom: 24 },
  title: { fontSize: 18, fontWeight: '800', color: '#101828', marginBottom: 8 },
  subTitle: { fontSize: 13, color: '#667085', marginBottom: 10 },
  sectionTitle: {
    fontSize: 16,
    fontWeight: '700',
    color: '#101828',
    marginBottom: 6,
  },

  workingWrap: {
    minHeight: 120,
    backgroundColor: '#F9FAFB',
    borderWidth: 1,
    borderColor: '#EEF2F7',
    borderRadius: 12,
    padding: 12,
    marginBottom: 12,
  },
  emptyHint: { fontSize: 13, color: '#98A2B3' },

  tiles: {
    marginTop: 8,
    gap: 8,
  },
  tile: {
    flexDirection: 'row',
    alignItems: 'center',
    borderWidth: 1,
    borderColor: '#E5ECF5',
    borderRadius: 12,
    paddingVertical: 8,
    paddingHorizontal: 10,
    backgroundColor: '#FFF',
    gap: 8,
  },
  tileSel: {
    backgroundColor: '#EEF4FF',
    borderColor: '#D1E0FF',
  },
  rect: {
    width: 16,
    height: 16,
    borderRadius: 4,
    backgroundColor: '#E6ECF5',
  },
  tileName: { fontSize: 14, fontWeight: '600', color: '#101828' },

  chip: {
    flexDirection: 'row',
    alignItems: 'center',
    borderWidth: 1,
    borderColor: '#E6ECF5',
    paddingVertical: 6,
    paddingHorizontal: 10,
    borderRadius: 999,
    gap: 6,
  },
  chipSel: { backgroundColor: '#175CD3', borderColor: '#175CD3' },
  chipTxt: { fontSize: 14, color: '#101828' },
  chipTxtSel: { color: '#FFF' },
  chipGrid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: 8,
    marginTop: 12,
  },

  assignedSummary: {
    fontSize: 12,
    color: '#667085',
    marginTop: 8,
  },

  assignmentsWrap: {
    marginTop: 12,
    gap: 12,
  },
  assignmentCard: {
    backgroundColor: '#FFF',
    borderWidth: 1,
    borderColor: '#E5ECF5',
    borderRadius: 12,
    padding: 10,
  },
  assignmentHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
    marginBottom: 8,
  },
  assignmentName: {
    fontSize: 15,
    fontWeight: '700',
    color: '#101828',
  },
  chipRow: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: 8,
  },

  footer: {
    paddingHorizontal: 16,
    paddingVertical: 12,
    borderTopWidth: 1,
    borderTopColor: '#E5ECF5',
    backgroundColor: '#FFF',
  },
  footerInner: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    maxWidth: 880,
    alignSelf: 'center',
    width: '100%',
    gap: 12,
  },
  btnBase: {
    flex: 1,
    paddingVertical: Platform.select({ ios: 10, android: 10, default: 8 }),
    borderRadius: 999,
    alignItems: 'center',
    justifyContent: 'center',
  },
  backBtn: {
    borderWidth: 1,
    borderColor: '#D0D5DD',
    backgroundColor: '#FFF',
  },
  backTxt: { fontSize: 14, color: '#344054', fontWeight: '600' },
  nextBtn: { backgroundColor: '#175CD3' },
  nextTxt: { fontSize: 14, color: '#FFF', fontWeight: '600' },
});
