// @ts-nocheck
import React, { useState, useMemo, useCallback, useEffect } from 'react';
import {
  View,
  Text,
  ScrollView,
  TouchableOpacity,
  StyleSheet,
  Platform,
} from 'react-native';
import { useLocalSearchParams, useRouter } from 'expo-router';
import { ChevronLeft, ChevronRight } from 'lucide-react-native';

import { useSchedule } from '../hooks/schedule-store';
import { persistFinish } from '../hooks/persist-finish';
import {
  STAFF,
  PARTICIPANTS,
  FLOATING_ROOMS,
  CLEANING_TASKS,
  FINAL_CHECKLIST_ITEMS,
  TIME_SLOTS,
} from '@/constants/data';
import { ROUTES } from '@/constants/ROUTES';
import useTodayLabel from '@/components/use-today-label';
import Chip from '@/components/Chip';

const PILL = 999;

// Helper
function safeArray<T>(val: T[] | undefined | null, fallback: T[] = []): T[] {
  return Array.isArray(val) ? val : fallback;
}

// Small chips used in multiple steps
type ChipProps = {
  label: string;
  selected?: boolean;
  onPress?: () => void;
  rightAddon?: React.ReactNode;
  disabled?: boolean;
};

function SmallChip({ label, selected, onPress, rightAddon, disabled }: ChipProps) {
  return (
    <TouchableOpacity
      onPress={disabled ? undefined : onPress}
      activeOpacity={0.85}
      style={[
        styles.chip,
        selected && styles.chipSel,
        disabled && styles.chipDisabled,
      ]}
    >
      <Text style={[styles.chipTxt, selected && styles.chipTxtSel]}>{label}</Text>
      {rightAddon}
    </TouchableOpacity>
  );
}

// Helper to derive attending participants from state
function deriveAttendingParticipants(
  allParticipants: typeof PARTICIPANTS,
  attendingIds: string[],
) {
  const attendingSet = new Set(attendingIds);
  return allParticipants.filter((p) => attendingSet.has(p.id));
}

// ---- MAIN SCREEN ------------------------------------------------------------

export default function CreateScheduleScreen() {
  const router = useRouter();
  const { date } = useLocalSearchParams<{ date?: string }>();
  const { updateSchedule } = useSchedule();

  const todayLabel = useTodayLabel(date ?? undefined);

  // ---- LOCAL STATE (fresh per wizard run) -------------------------------

  // Only Everyone on by default for a new schedule
  const [workingStaff, setWorkingStaff] = useState<string[]>(['everyone']);

  // No participants pre-selected; user chooses each time
  const [attendingParticipants, setAttendingParticipants] = useState<string[]>([]);

  // Empty assignments until the user sets them in Step 3
  const [assignments, setAssignments] = useState<{ [staffId: string]: string[] }>(
    {},
  );

  // Transport: start with no pickups or helpers
  const [pickupIds, setPickupIds] = useState<string[]>([]);
  const [helpers, setHelpers] = useState<string[]>([]);

  // Dropoffs: no one assigned initially
  const [dropoffs, setDropoffs] = useState<{ [staffId: string]: string[] }>({});

  // Cleaning & floating: no pre-assignments
  const [cleaning, setCleaning] = useState<{ [taskId: string]: string }>({});
  const [floating, setFloating] = useState<{
    [slotId: string]: { front?: string; scotty?: string; twins?: string };
  }>({});
  const [showHelpers, setShowHelpers] = useState(false);
  const [step, setStep] = useState<number>(1);
  const [autoGenerated, setAutoGenerated] = useState(false);

  const dateKey =
    typeof date === 'string' && date.length > 0 ? date : todayLabel.rawKey;

  // Persist full schedule on finish
  const handleFinish = async () => {
    const payload = {
      date: dateKey,
      workingStaff: workingStaff,
      attendingParticipants,
      participantAssignments: assignments,
      pickups: pickupIds,
      dropoffHelpers: helpers,
      dropoffAssignments: dropoffs,
      cleaningAssignments: cleaning,
      floatingAssignments: floating,
    };

    updateSchedule(payload);
    await persistFinish(payload);
    router.replace(ROUTES.EDIT_HUB);
  };

  const handleNext = () => {
    if (step < 6) setStep((s) => s + 1);
    else handleFinish();
  };

  const handleBack = () => {
    if (step > 1) setStep((s) => s - 1);
    else router.replace(ROUTES.HOME);
  };

  // ---- DERIVED DATA ---------------------------------------------------------

  const workingStaffSet = useMemo(() => new Set(workingStaff), [workingStaff]);

  const selectedWorkingStaff = useMemo(
    () => STAFF.filter((s) => workingStaffSet.has(s.id)),
    [workingStaffSet],
  );

  const nonWorkingStaff = useMemo(
    () => STAFF.filter((s) => !workingStaffSet.has(s.id)),
    [workingStaffSet],
  );

  const attendingSet = useMemo(
    () => new Set(attendingParticipants),
    [attendingParticipants],
  );

  const attendingList = useMemo(
    () => deriveAttendingParticipants(PARTICIPANTS, attendingParticipants),
    [attendingParticipants],
  );

  const availableParticipants = useMemo(
    () => PARTICIPANTS.filter((p) => !attendingSet.has(p.id)),
    [attendingSet],
  );

  const nonPickupParticipants = useMemo(() => {
    const pickSet = new Set(pickupIds);
    return attendingList.filter((p) => !pickSet.has(p.id));
  }, [pickupIds, attendingList]);

  const pickupSet = useMemo(() => new Set(pickupIds), [pickupIds]);

  const helpersSet = useMemo(() => new Set(helpers), [helpers]);

  const dropoffStaffIds = useMemo(
    () => selectedWorkingStaff.map((s) => s.id),
    [selectedWorkingStaff],
  );

  const allDropoffAssignedIds = useMemo(() => {
    const all = new Set<string>();
    Object.values(dropoffs).forEach((arr) => {
      arr.forEach((id) => all.add(id));
    });
    return all;
  }, [dropoffs]);

  const unassignedForDropoff = useMemo(() => {
    return nonPickupParticipants.filter((p) => !allDropoffAssignedIds.has(p.id));
  }, [nonPickupParticipants, allDropoffAssignedIds]);

  // ---- TOGGLE HANDLERS ------------------------------------------------------

  const toggleWorking = (id: string) => {
    // Everyone special case
    if (id === 'everyone') {
      const isOn = workingStaffSet.has('everyone');
      if (isOn) {
        setWorkingStaff(['everyone']);
      } else {
        setWorkingStaff(['everyone', ...STAFF.map((s) => s.id)]);
      }
      return;
    }

    const next = new Set(workingStaff);
    if (next.has(id)) next.delete(id);
    else next.add(id);
    if (!next.has('everyone')) {
      next.add('everyone');
    }
    setWorkingStaff(Array.from(next));
  };

  const toggleAttending = (id: string) => {
    const next = new Set(attendingParticipants);
    if (next.has(id)) next.delete(id);
    else next.add(id);
    setAttendingParticipants(Array.from(next));
  };

  const toggleAssignment = (staffId: string, participantId: string) => {
    setAssignments((prev) => {
      const next = { ...prev };
      const staffSet = new Set<string>(safeArray(prev[staffId], []));

      const assignedElsewhere = Object.entries(prev).some(
        ([sid, arr]) => sid !== staffId && safeArray(arr).includes(participantId),
      );

      if (staffSet.has(participantId)) {
        staffSet.delete(participantId);
      } else {
        if (assignedElsewhere) {
          // remove from other staff first
          Object.entries(next).forEach(([sid, arr]) => {
            if (sid === staffId) return;
            if (safeArray(arr).includes(participantId)) {
              next[sid] = safeArray(arr).filter((id) => id !== participantId);
            }
          });
        }
        staffSet.add(participantId);
      }

      next[staffId] = Array.from(staffSet);
      return next;
    });
  };

  const toggleCleaning = (taskId: string, staffId: string) => {
    setCleaning((prev) => {
      if (prev[taskId] === staffId) {
        const next = { ...prev };
        delete next[taskId];
        return next;
      }
      return { ...prev, [taskId]: staffId };
    });
  };

  const toggleFloatingSlot = (
    slotId: string,
    roomId: string,
    staffId: string,
  ) => {
    setFloating((prev) => {
      const slot = prev[slotId] || {};
      const current = slot[roomId];
      if (current === staffId) {
        const nextSlot = { ...slot };
        delete nextSlot[roomId];
        return { ...prev, [slotId]: nextSlot };
      }
      return {
        ...prev,
        [slotId]: { ...slot, [roomId]: staffId },
      };
    });
  };

  const togglePickupParticipant = (participantId: string) => {
    setPickupIds((prev) => {
      const next = new Set(prev);
      if (next.has(participantId)) next.delete(participantId);
      else next.add(participantId);
      return Array.from(next);
    });
  };

  const toggleHelperStaff = (staffId: string) => {
    setHelpers((prev) => {
      const next = new Set(prev);
      if (next.has(staffId)) next.delete(staffId);
      else next.add(staffId);
      return Array.from(next);
    });
  };

  const toggleDropoffParticipant = (staffId: string, participantId: string) => {
    setDropoffs((prev) => {
      const next = { ...prev };

      const assignedElsewhere = Object.entries(prev).some(([sid, arr]) =>
        safeArray(arr).includes(participantId),
      );

      const staffSet = new Set<string>(safeArray(prev[staffId], []));

      if (staffSet.has(participantId)) {
        staffSet.delete(participantId);
      } else {
        if (assignedElsewhere) {
          Object.entries(next).forEach(([sid, arr]) => {
            if (sid === staffId) return;
            if (safeArray(arr).includes(participantId)) {
              next[sid] = safeArray(arr).filter((id) => id !== participantId);
            }
          });
        }
        staffSet.add(participantId);
      }

      next[staffId] = Array.from(staffSet);
      return next;
    });
  };

  // ---------------------------------------------------------------------------
  // STEP SUBCOMPONENTS
  // ---------------------------------------------------------------------------

  const Step1 = () => {
    const selected = new Set(workingStaff);

    const staffSorted = [...STAFF].sort((a, b) =>
      a.name.localeCompare(b.name, 'en', { sensitivity: 'base' }),
    );

    const topSelected = staffSorted.filter((s) => selected.has(s.id));
    const remaining = staffSorted.filter((s) => !selected.has(s.id));

    return (
      <View style={styles.section}>
        <Text style={styles.title}>Dream Team (Working @ B2)</Text>
        <Text style={styles.subTitle}>
          Select who&apos;s working @ B2 today. &quot;Everyone&quot; lets you
          quickly toggle the whole team. Staff not working here can still be
          used as dropoff helpers later.
        </Text>

        <Text style={styles.sectionTitle}>Working here today</Text>
        <View style={styles.tiles}>
          {topSelected.length === 0 && (
            <Text style={styles.emptyHint}>
              Select at least one staff member working @ B2 today.
            </Text>
          )}

          {topSelected.map((s) => (
            <TouchableOpacity
              key={s.id}
              onPress={() => toggleWorking(s.id)}
              activeOpacity={0.85}
              style={[styles.tile, styles.tileSel, { flex: 1 }]}
            >
              <View style={[styles.rect, { backgroundColor: s.color }]} />
              <Text style={styles.tileName}>{s.name}</Text>
              <Text style={{ marginLeft: 'auto', color: '#175CD3' }}>✓</Text>
            </TouchableOpacity>
          ))}
        </View>

        {/* Remaining staff list */}
        {remaining.length > 0 && (
          <>
            <Text
              style={{
                marginTop: 16,
                fontSize: 13,
                color: '#667085',
              }}
            >
              Team members
            </Text>
            <View style={styles.tiles}>
              {remaining.map((s) => (
                <TouchableOpacity
                  key={s.id}
                  onPress={() => toggleWorking(s.id)}
                  activeOpacity={0.85}
                  style={[styles.tile, { flex: 1 }]}
                >
                  <View
                    style={[styles.rect, { backgroundColor: s.color }]}
                  />
                  <Text style={styles.tileName}>{s.name}</Text>
                  {selected.has(s.id) && (
                    <Text style={{ marginLeft: 'auto', color: '#175CD3' }}>
                      ✓
                    </Text>
                  )}
                </TouchableOpacity>
              ))}
            </View>
          </>
        )}

        <View style={{ marginTop: 16 }}>
          <Text style={styles.sectionTitle}>Quick toggle</Text>
          <View style={styles.chipRow}>
            <SmallChip
              label="Everyone"
              selected={selected.has('everyone')}
              onPress={() => toggleWorking('everyone')}
            />
          </View>
        </View>
      </View>
    );
  };

  const Step2 = () => {
    const selected = new Set(attendingParticipants);

    const attendingSorted = [...PARTICIPANTS].sort((a, b) =>
      a.name.localeCompare(b.name, 'en', { sensitivity: 'base' }),
    );

    const topSelected = attendingSorted.filter((p) => selected.has(p.id));
    const remaining = attendingSorted.filter((p) => !selected.has(p.id));

    return (
      <View style={styles.section}>
        <Text style={styles.title}>Attending Participants</Text>
        <Text style={styles.subTitle}>
          Choose which participants are attending today. Only these will appear
          in the later assignment steps.
        </Text>

        <Text style={styles.sectionTitle}>Attending today</Text>
        <View style={styles.tiles}>
          {topSelected.length === 0 && (
            <Text style={styles.emptyHint}>
              Select at least one participant attending today.
            </Text>
          )}

          {topSelected.map((p) => (
            <TouchableOpacity
              key={p.id}
              onPress={() => toggleAttending(p.id)}
              activeOpacity={0.85}
              style={[
                styles.tile,
                selected.has(p.id) && styles.tileSel,
                { flex: 1 },
              ]}
            >
              <Text style={styles.tileName}>{p.name}</Text>
              {selected.has(p.id) && (
                <Text style={{ marginLeft: 'auto', color: '#175CD3' }}>✓</Text>
              )}
            </TouchableOpacity>
          ))}
        </View>

        {remaining.length > 0 && (
          <>
            <Text
              style={{
                marginTop: 16,
                fontSize: 13,
                color: '#667085',
              }}
            >
              Not attending
            </Text>
            <View style={styles.tiles}>
              {remaining.map((p) => (
                <TouchableOpacity
                  key={p.id}
                  onPress={() => toggleAttending(p.id)}
                  activeOpacity={0.85}
                  style={[styles.tile, { flex: 1 }]}
                >
                  <Text style={styles.tileName}>{p.name}</Text>
                  {selected.has(p.id) && (
                    <Text style={{ marginLeft: 'auto', color: '#175CD3' }}>
                      ✓
                    </Text>
                  )}
                </TouchableOpacity>
              ))}
            </View>
          </>
        )}
      </View>
    );
  };

  const Step3 = () => {
    const staffList = selectedWorkingStaff;
    const participantsList = attendingList;

    return (
      <View style={styles.section}>
        <Text style={styles.title}>Team Daily Assignments</Text>
        <Text style={styles.subTitle}>
          Assign attending participants to each staff member.
        </Text>

        <View style={{ gap: 16 }}>
          {staffList.map((s) => {
            const assignedIds = new Set(safeArray(assignments[s.id], []));
            const chips = participantsList.map((p) => ({
              id: p.id,
              name: p.name,
              selected: assignedIds.has(p.id),
            }));

            return (
              <View key={s.id} style={styles.assignmentBlock}>
                <View style={styles.assignmentHeader}>
                  <View
                    style={[styles.rect, { backgroundColor: s.color }]}
                  />
                  <Text style={styles.assignmentTitle}>{s.name}</Text>
                </View>
                <View style={styles.chipRowWrap}>
                  {chips.map((c) => (
                    <Chip
                      key={c.id}
                      label={c.name}
                      selected={c.selected}
                      onPress={() => toggleAssignment(s.id, c.id)}
                    />
                  ))}
                </View>
              </View>
            );
          })}
        </View>
      </View>
    );
  };

  const Step4 = () => {
    const staffList = selectedWorkingStaff;

    return (
      <View style={styles.section}>
        <Text style={styles.title}>Floating Assignments</Text>
        <Text style={styles.subTitle}>
          Assign staff to the Front Room, Scotty, and Twins across the day.
        </Text>

        <ScrollView horizontal showsHorizontalScrollIndicator={false}>
          <View>
            <View style={styles.floatingHeaderRow}>
              <Text style={[styles.floatingCell, styles.floatingTimeCol]}>
                Time
              </Text>
              {FLOATING_ROOMS.map((room) => (
                <Text
                  key={room.id}
                  style={[styles.floatingCell, styles.floatingRoomCol]}
                >
                  {room.label}
                </Text>
              ))}
            </View>

            {TIME_SLOTS.map((slot) => (
              <View key={slot.id} style={styles.floatingRow}>
                <Text style={[styles.floatingCell, styles.floatingTimeCol]}>
                  {slot.label}
                </Text>
                {FLOATING_ROOMS.map((room) => {
                  const slotAssignments = floating[slot.id] || {};
                  const currentStaffId = slotAssignments[room.id];
                  const currentStaff = staffList.find(
                    (s) => s.id === currentStaffId,
                  );

                  return (
                    <View
                      key={room.id}
                      style={[styles.floatingCell, styles.floatingRoomCol]}
                    >
                      <ScrollView
                        horizontal
                        showsHorizontalScrollIndicator={false}
                      >
                        <View style={styles.chipRow}>
                          {staffList.map((s) => (
                            <SmallChip
                              key={s.id}
                              label={s.name}
                              selected={currentStaffId === s.id}
                              onPress={() =>
                                toggleFloatingSlot(slot.id, room.id, s.id)
                              }
                            />
                          ))}
                        </View>
                      </ScrollView>
                    </View>
                  );
                })}
              </View>
            ))}
          </View>
        </ScrollView>
      </View>
    );
  };

  const Step5 = () => {
    const staffList = selectedWorkingStaff;

    return (
      <View style={styles.section}>
        <Text style={styles.title}>Cleaning Assignments</Text>
        <Text style={styles.subTitle}>
          Assign cleaning tasks to staff working at B2.
        </Text>

        <View style={{ gap: 16 }}>
          {CLEANING_TASKS.map((task) => (
            <View key={task.id} style={styles.assignmentBlock}>
              <Text style={styles.assignmentTitle}>{task.title}</Text>
              <View style={styles.chipRowWrap}>
                {staffList.map((s) => (
                  <SmallChip
                    key={s.id}
                    label={s.name}
                    selected={cleaning[task.id] === s.id}
                    onPress={() => toggleCleaning(task.id, s.id)}
                  />
                ))}
              </View>
            </View>
          ))}
        </View>
      </View>
    );
  };

  const Step6 = () => {
    const pickupsChips = attendingList.map((p) => ({
      id: p.id,
      name: p.name,
      selected: pickupSet.has(p.id),
    }));

    const helperCandidates = nonWorkingStaff;

    return (
      <View style={styles.section}>
        <Text style={styles.title}>Pickups & Dropoffs</Text>
        <Text style={styles.subTitle}>
          Choose which participants are picked up by third parties, add helper
          staff for transport, and assign dropoffs.
        </Text>

        {/* Pickups */}
        <View style={styles.assignmentBlock}>
          <Text style={styles.assignmentTitle}>Participants with pickups</Text>
          <View style={styles.chipRowWrap}>
            {pickupsChips.map((c) => (
              <Chip
                key={c.id}
                label={c.name}
                selected={c.selected}
                onPress={() => togglePickupParticipant(c.id)}
              />
            ))}
          </View>
        </View>

        {/* Helpers toggle */}
        <View style={[styles.assignmentBlock, { marginTop: 16 }]}>
          <View style={styles.helpersHeader}>
            <Text style={styles.assignmentTitle}>Transport helpers</Text>
            <TouchableOpacity
              onPress={() => setShowHelpers((v) => !v)}
              activeOpacity={0.85}
            >
              <Text style={styles.showHelpers}>
                {showHelpers ? 'Hide helpers' : 'Show helpers'}
              </Text>
            </TouchableOpacity>
          </View>

          {showHelpers && (
            <View style={styles.chipRowWrap}>
              {helperCandidates.map((s) => (
                <Chip
                  key={s.id}
                  label={s.name}
                  selected={helpersSet.has(s.id)}
                  onPress={() => toggleHelperStaff(s.id)}
                />
              ))}
            </View>
          )}
        </View>

        {/* Dropoff assignments */}
        <View style={[styles.assignmentBlock, { marginTop: 16 }]}>
          <Text style={styles.assignmentTitle}>Dropoff assignments</Text>
          <Text style={[styles.subTitle, { marginBottom: 8 }]}>
            Assign non-pickup participants to staff for dropoff. You can move
            participants between staff.
          </Text>

          {dropoffStaffIds.length === 0 && (
            <Text style={styles.emptyHint}>
              Select at least one working staff member in Step 1.
            </Text>
          )}

          {dropoffStaffIds.length > 0 && (
            <View style={{ gap: 12 }}>
              {dropoffStaffIds.map((staffId) => {
                const staff = selectedWorkingStaff.find((s) => s.id === staffId);
                if (!staff) return null;
                const staffLabel = staff.name;
                const assignedIds = new Set(
                  safeArray(dropoffs[staffId], []),
                );
                const assigned = nonPickupParticipants.filter((p) =>
                  assignedIds.has(p.id),
                );
                const unassigned = nonPickupParticipants.filter(
                  (p) => !assignedIds.has(p.id),
                );

                return (
                  <View key={staffId} style={styles.assignmentBlockInner}>
                    <View style={styles.assignmentHeader}>
                      <View
                        style={[styles.rect, { backgroundColor: staff.color }]}
                      />
                      <Text style={styles.assignmentTitle}>{staffLabel}</Text>
                    </View>

                    {/* Assigned list */}
                    <View style={styles.chipRowWrap}>
                      {assigned.map((p) => (
                        <Chip
                          key={p.id}
                          label={p.name}
                          selected
                          onPress={() =>
                            toggleDropoffParticipant(staffId, p.id)
                          }
                        />
                      ))}
                    </View>

                    {/* Unassigned list */}
                    {unassigned.length > 0 && (
                      <>
                        <Text
                          style={[
                            styles.subTitle,
                            { marginTop: 12, marginBottom: 4 },
                          ]}
                        >
                          Not assigned to {staffLabel}
                        </Text>
                        <View style={styles.chipRow}>
                          {unassigned.map((p) => (
                            <Chip
                              key={p.id}
                              label={p.name}
                              onPress={() =>
                                toggleDropoffParticipant(staffId, p.id)
                              }
                            />
                          ))}
                        </View>
                      </>
                    )}
                  </View>
                );
              })}
            </View>
          )}

          {/* Unassigned summary */}
          {unassignedForDropoff.length > 0 && (
            <Text style={[styles.emptyHint, { marginTop: 12 }]}>
              Unassigned participants:{' '}
              {unassignedForDropoff.map((p) => p.name).join(', ')}
            </Text>
          )}
        </View>
      </View>
    );
  };

  // ---- RENDER ---------------------------------------------------------------

  let content: JSX.Element | null = null;
  switch (step) {
    case 1:
      content = <Step1 />;
      break;
    case 2:
      content = <Step2 />;
      break;
    case 3:
      content = <Step3 />;
      break;
    case 4:
      content = <Step4 />;
      break;
    case 5:
      content = <Step5 />;
      break;
    case 6:
      content = <Step6 />;
      break;
    default:
      content = <Step1 />;
  }

  return (
    <View style={styles.screen}>
      <View style={styles.header}>
        <View>
          <Text style={styles.headerTitle}>Create Schedule</Text>
          <Text style={styles.headerSubTitle}>{todayLabel.label}</Text>
        </View>

        <View style={styles.stepBadge}>
          <Text style={styles.stepBadgeTxt}>Step {step} of 6</Text>
        </View>
      </View>

      <ScrollView
        style={{ flex: 1 }}
        contentContainerStyle={styles.scrollContent}
        keyboardShouldPersistTaps="handled"
      >
        <View style={styles.inner}>{content}</View>
      </ScrollView>

      <View style={styles.stepControls}>
        <TouchableOpacity
          style={[styles.stepBtn, styles.backBtn]}
          onPress={handleBack}
          activeOpacity={0.85}
        >
          <ChevronLeft size={16} color="#344054" />
          <Text style={styles.backTxt}>Back</Text>
        </TouchableOpacity>

        <TouchableOpacity
          style={[styles.stepBtn, styles.nextBtn]}
          onPress={handleNext}
          activeOpacity={0.85}
        >
          <Text style={styles.nextTxt}>{step < 6 ? 'Next' : 'Finish'}</Text>
          <ChevronRight size={16} color="#FFF" />
        </TouchableOpacity>
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  screen: {
    flex: 1,
    backgroundColor: '#F9FAFB',
  },
  header: {
    paddingTop: Platform.select({ ios: 52, android: 32, default: 24 }),
    paddingBottom: 12,
    paddingHorizontal: 16,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
  },
  headerTitle: { fontSize: 20, fontWeight: '700', color: '#101828' },
  headerSubTitle: { marginTop: 2, fontSize: 13, color: '#667085' },
  stepBadge: {
    paddingHorizontal: 10,
    paddingVertical: 4,
    borderRadius: PILL,
    backgroundColor: '#EFF4FF',
  },
  stepBadgeTxt: { fontSize: 12, fontWeight: '600', color: '#175CD3' },
  scrollContent: {
    paddingHorizontal: 16,
    paddingBottom: 100,
  },
  inner: {
    maxWidth: 880,
    width: '100%',
    alignSelf: 'center',
  },
  section: {
    paddingVertical: 16,
  },
  title: {
    fontSize: 18,
    fontWeight: '700',
    color: '#101828',
    marginBottom: 4,
  },
  subTitle: {
    fontSize: 13,
    color: '#667085',
    marginBottom: 16,
  },
  sectionTitle: {
    fontSize: 14,
    fontWeight: '600',
    color: '#344054',
    marginBottom: 8,
  },
  emptyHint: {
    fontSize: 13,
    color: '#98A2B3',
  },
  tiles: {
    marginTop: 8,
    gap: 8,
  },
  tile: {
    flexDirection: 'row',
    alignItems: 'center',
    borderWidth: 1,
    borderColor: '#E5ECF5',
    borderRadius: 12,
    paddingVertical: 8,
    paddingHorizontal: 10,
    backgroundColor: '#FFF',
    gap: 8,
  },
  tileSel: {
    borderColor: '#175CD3',
    backgroundColor: '#EFF4FF',
  },
  rect: {
    width: 16,
    height: 16,
    borderRadius: 4,
    backgroundColor: '#E6ECF5',
  },
  tileName: { fontSize: 14, fontWeight: '600', color: '#101828' },

  chip: {
    flexDirection: 'row',
    alignItems: 'center',
    borderWidth: 1,
    borderColor: '#E6ECF5',
    borderRadius: PILL,
    paddingHorizontal: 10,
    paddingVertical: 4,
    marginRight: 8,
    marginBottom: 8,
  },
  chipSel: {
    borderColor: '#175CD3',
    backgroundColor: '#EFF4FF',
  },
  chipDisabled: {
    opacity: 0.5,
  },
  chipTxt: {
    fontSize: 13,
    color: '#344054',
  },
  chipTxtSel: {
    color: '#175CD3',
    fontWeight: '600',
  },
  chipRow: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    alignItems: 'center',
  },
  chipRowWrap: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    alignItems: 'center',
  },
  assignmentBlock: {
    borderWidth: 1,
    borderColor: '#E5ECF5',
    borderRadius: 12,
    padding: 12,
    backgroundColor: '#FFF',
  },
  assignmentBlockInner: {
    borderWidth: 1,
    borderColor: '#E5ECF5',
    borderRadius: 12,
    padding: 10,
    backgroundColor: '#FFF',
  },
  assignmentHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 8,
    gap: 8,
  },
  assignmentTitle: {
    fontSize: 14,
    fontWeight: '600',
    color: '#101828',
  },
  floatingHeaderRow: {
    flexDirection: 'row',
    borderBottomWidth: 1,
    borderBottomColor: '#E5ECF5',
    backgroundColor: '#F9FAFB',
  },
  floatingRow: {
    flexDirection: 'row',
    borderBottomWidth: 1,
    borderBottomColor: '#E5ECF5',
  },
  floatingCell: {
    paddingVertical: 8,
    paddingHorizontal: 8,
    borderRightWidth: 1,
    borderRightColor: '#E5ECF5',
  },
  floatingTimeCol: {
    minWidth: 80,
  },
  floatingRoomCol: {
    minWidth: 140,
  },
  helpersHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
  },
  showHelpers: {
    fontSize: 13,
    color: '#175CD3',
    fontWeight: '600',
  },
  stepControls: {
    position: 'absolute',
    left: 0,
    right: 0,
    bottom: Platform.select({ ios: 16, android: 16, default: 12 }),
    paddingHorizontal: 16,
    flexDirection: 'row',
    justifyContent: 'space-between',
    gap: 12,
  },
  stepBtn: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    flex: 1,
    gap: 6,
    paddingHorizontal: 12,
    paddingVertical: Platform.select({ ios: 10, android: 10, default: 8 }),
    borderRadius: 999,
    alignItems: 'center',
    justifyContent: 'center',
  },
  backBtn: {
    borderWidth: 1,
    borderColor: '#D0D5DD',
    backgroundColor: '#FFF',
  },
  backTxt: { fontSize: 14, color: '#344054', fontWeight: '600' },
  nextBtn: { backgroundColor: '#175CD3' },
  nextTxt: { fontSize: 14, color: '#FFF', fontWeight: '600' },
});
